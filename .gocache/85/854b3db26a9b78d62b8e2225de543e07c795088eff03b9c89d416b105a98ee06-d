// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/linuxbrew/.linuxbrew/Cellar/go/1.25.1/libexec/src/plugin/plugin_dlopen.go:1:1
// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build (linux && cgo) || (darwin && cgo) || (freebsd && cgo)

package plugin; import _cgo_unsafe "unsafe"

/*
#cgo linux LDFLAGS: -ldl
#include <dlfcn.h>
#include <limits.h>
#include <stdlib.h>
#include <stdint.h>

#include <stdio.h>

static uintptr_t pluginOpen(const char* path, char** err) {
	void* h = dlopen(path, RTLD_NOW|RTLD_GLOBAL);
	if (h == NULL) {
		*err = (char*)dlerror();
	}
	return (uintptr_t)h;
}

static void* pluginLookup(uintptr_t h, const char* name, char** err) {
	void* r = dlsym((void*)h, name);
	if (r == NULL) {
		*err = (char*)dlerror();
	}
	return r;
}
*/
import _ "unsafe"

import (
	"errors"
	"sync"
	"unsafe"
)

func open(name string) (*Plugin, error) {
	cPath := make([]byte, ( /*line :43:24*/_Ciconst_PATH_MAX /*line :43:33*/)+1)
	cRelName := make([]byte, len(name)+1)
	copy(cRelName, name)
	if ( /*line :46:5*/_Cfunc_realpath /*line :46:14*/)(
		(* /*line :47:5*/_Ctype_char /*line :47:11*/)(unsafe.Pointer(&cRelName[0])),
		(* /*line :48:5*/_Ctype_char /*line :48:11*/)(unsafe.Pointer(&cPath[0]))) == nil {
		return nil, errors.New(`plugin.Open("` + name + `"): realpath failed`)
	}

	filepath := ( /*line :52:14*/_Cfunc_GoString /*line :52:23*/)((* /*line :52:27*/_Ctype_char /*line :52:33*/)(unsafe.Pointer(&cPath[0])))

	pluginsMu.Lock()
	if p := plugins[filepath]; p != nil {
		pluginsMu.Unlock()
		if p.err != "" {
			return nil, errors.New(`plugin.Open("` + name + `"): ` + p.err + ` (previous failure)`)
		}
		<-p.loaded
		return p, nil
	}
	var cErr * /*line :63:12*/_Ctype_char /*line :63:18*/
	h := func() _Ctype_uintptr_t{ var _cgo0 *_Ctype_char = /*line :64:20*/(*_Ctype_char /*line :64:28*/)(unsafe.Pointer(&cPath[0])); _cgoBase1 := /*line :64:58*/&cErr; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :64:64*/_Cfunc_pluginOpen(_cgo0, _cgo1); }()
	if h == 0 {
		pluginsMu.Unlock()
		return nil, errors.New(`plugin.Open("` + name + `"): ` + ( /*line :67:60*/_Cfunc_GoString /*line :67:69*/)(cErr))
	}
	// TODO(crawshaw): look for plugin note, confirm it is a Go plugin
	// and it was built with the correct toolchain.
	if len(name) > 3 && name[len(name)-3:] == ".so" {
		name = name[:len(name)-3]
	}
	if plugins == nil {
		plugins = make(map[string]*Plugin)
	}
	pluginpath, syms, initTasks, errstr := lastmoduleinit()
	if errstr != "" {
		plugins[filepath] = &Plugin{
			pluginpath: pluginpath,
			err:        errstr,
		}
		pluginsMu.Unlock()
		return nil, errors.New(`plugin.Open("` + name + `"): ` + errstr)
	}
	// This function can be called from the init function of a plugin.
	// Drop a placeholder in the map so subsequent opens can wait on it.
	p := &Plugin{
		pluginpath: pluginpath,
		loaded:     make(chan struct{}),
	}
	plugins[filepath] = p
	pluginsMu.Unlock()

	doInit(initTasks)

	// Fill out the value of each plugin symbol.
	updatedSyms := map[string]any{}
	for symName, sym := range syms {
		isFunc := symName[0] == '.'
		if isFunc {
			delete(syms, symName)
			symName = symName[1:]
		}

		fullName := pluginpath + "." + symName
		cname := make([]byte, len(fullName)+1)
		copy(cname, fullName)

		p := func() _cgo_unsafe.Pointer{ var _cgo0 _Ctype_uintptr_t = /*line :110:23*/h; var _cgo1 *_Ctype_char = /*line :110:26*/(*_Ctype_char /*line :110:34*/)(unsafe.Pointer(&cname[0])); _cgoBase2 := /*line :110:64*/&cErr; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :110:70*/_Cfunc_pluginLookup(_cgo0, _cgo1, _cgo2); }()
		if p == nil {
			return nil, errors.New(`plugin.Open("` + name + `"): could not find symbol ` + symName + `: ` + ( /*line :112:100*/_Cfunc_GoString /*line :112:109*/)(cErr))
		}
		valp := (*[2]unsafe.Pointer)(unsafe.Pointer(&sym))
		if isFunc {
			(*valp)[1] = unsafe.Pointer(&p)
		} else {
			(*valp)[1] = p
		}
		// we can't add to syms during iteration as we'll end up processing
		// some symbols twice with the inability to tell if the symbol is a function
		updatedSyms[symName] = sym
	}
	p.syms = updatedSyms

	close(p.loaded)
	return p, nil
}

func lookup(p *Plugin, symName string) (Symbol, error) {
	if s := p.syms[symName]; s != nil {
		return s, nil
	}
	return nil, errors.New("plugin: symbol " + symName + " not found in plugin " + p.pluginpath)
}

var (
	pluginsMu sync.Mutex
	plugins   map[string]*Plugin
)

// lastmoduleinit is defined in package runtime.
func lastmoduleinit() (pluginpath string, syms map[string]any, inittasks []*initTask, errstr string)

// doInit is defined in package runtime.
//
//go:linkname doInit runtime.doInit
func doInit(t []*initTask)

type initTask struct {
	// fields defined in runtime.initTask. We only handle pointers to an initTask
	// in this package, so the contents are irrelevant.
}
