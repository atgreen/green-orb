// Code generated by generate-tests; DO NOT EDIT.

package main

import (
	"regexp"
	. "regexp"
	pkg "regexp"
)


func main_regexp() {
	{
		
		_,_ = regexp.Match("foo", []byte("foobar")) // want `avoid allocations with regexp\.MatchString`
	}

	{
		
		_,_ = regexp.Match("foo", []byte{'f','o','o','b','a','r'}) 
	}

	{
		
		_,_ = Match("foo", []byte("foobar")) // want `avoid allocations with regexp\.MatchString`
	}

	{
		
		_,_ = Match("foo", []byte{'f','o','o','b','a','r'}) 
	}

	{
		
		_,_ = pkg.Match("foo", []byte("foobar")) // want `avoid allocations with regexp\.MatchString`
	}

	{
		
		_,_ = pkg.Match("foo", []byte{'f','o','o','b','a','r'}) 
	}

	{
		
		_,_ = regexp.MatchString("foo", string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with regexp\.Match`
	}

	{
		
		_,_ = regexp.MatchString("foo", "foobar") 
	}

	{
		
		_,_ = MatchString("foo", string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with regexp\.Match`
	}

	{
		
		_,_ = MatchString("foo", "foobar") 
	}

	{
		
		_,_ = pkg.MatchString("foo", string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with regexp\.Match`
	}

	{
		
		_,_ = pkg.MatchString("foo", "foobar") 
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindAllIndex([]byte("foobar"), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllStringIndex`
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindAllIndex([]byte{'f','o','o','b','a','r'}, 1) 
	}

	{
		re := MustCompile(".*")
		_ = re.FindAllIndex([]byte("foobar"), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllStringIndex`
	}

	{
		re := MustCompile(".*")
		_ = re.FindAllIndex([]byte{'f','o','o','b','a','r'}, 1) 
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindAllIndex([]byte("foobar"), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllStringIndex`
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindAllIndex([]byte{'f','o','o','b','a','r'}, 1) 
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindAllStringIndex(string([]byte{'f','o','o','b','a','r'}), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllIndex`
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindAllStringIndex("foobar", 1) 
	}

	{
		re := MustCompile(".*")
		_ = re.FindAllStringIndex(string([]byte{'f','o','o','b','a','r'}), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllIndex`
	}

	{
		re := MustCompile(".*")
		_ = re.FindAllStringIndex("foobar", 1) 
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindAllStringIndex(string([]byte{'f','o','o','b','a','r'}), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllIndex`
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindAllStringIndex("foobar", 1) 
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindAllStringSubmatchIndex(string([]byte{'f','o','o','b','a','r'}), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllSubmatchIndex`
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindAllStringSubmatchIndex("foobar", 1) 
	}

	{
		re := MustCompile(".*")
		_ = re.FindAllStringSubmatchIndex(string([]byte{'f','o','o','b','a','r'}), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllSubmatchIndex`
	}

	{
		re := MustCompile(".*")
		_ = re.FindAllStringSubmatchIndex("foobar", 1) 
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindAllStringSubmatchIndex(string([]byte{'f','o','o','b','a','r'}), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllSubmatchIndex`
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindAllStringSubmatchIndex("foobar", 1) 
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindAllSubmatchIndex([]byte("foobar"), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllStringSubmatchIndex`
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindAllSubmatchIndex([]byte{'f','o','o','b','a','r'}, 1) 
	}

	{
		re := MustCompile(".*")
		_ = re.FindAllSubmatchIndex([]byte("foobar"), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllStringSubmatchIndex`
	}

	{
		re := MustCompile(".*")
		_ = re.FindAllSubmatchIndex([]byte{'f','o','o','b','a','r'}, 1) 
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindAllSubmatchIndex([]byte("foobar"), 1) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindAllStringSubmatchIndex`
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindAllSubmatchIndex([]byte{'f','o','o','b','a','r'}, 1) 
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindIndex([]byte("foobar")) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindStringIndex`
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindIndex([]byte{'f','o','o','b','a','r'}) 
	}

	{
		re := MustCompile(".*")
		_ = re.FindIndex([]byte("foobar")) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindStringIndex`
	}

	{
		re := MustCompile(".*")
		_ = re.FindIndex([]byte{'f','o','o','b','a','r'}) 
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindIndex([]byte("foobar")) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindStringIndex`
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindIndex([]byte{'f','o','o','b','a','r'}) 
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindStringIndex(string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindIndex`
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindStringIndex("foobar") 
	}

	{
		re := MustCompile(".*")
		_ = re.FindStringIndex(string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindIndex`
	}

	{
		re := MustCompile(".*")
		_ = re.FindStringIndex("foobar") 
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindStringIndex(string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindIndex`
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindStringIndex("foobar") 
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindStringSubmatchIndex(string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindSubmatchIndex`
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindStringSubmatchIndex("foobar") 
	}

	{
		re := MustCompile(".*")
		_ = re.FindStringSubmatchIndex(string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindSubmatchIndex`
	}

	{
		re := MustCompile(".*")
		_ = re.FindStringSubmatchIndex("foobar") 
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindStringSubmatchIndex(string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindSubmatchIndex`
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindStringSubmatchIndex("foobar") 
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindSubmatchIndex([]byte("foobar")) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindStringSubmatchIndex`
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.FindSubmatchIndex([]byte{'f','o','o','b','a','r'}) 
	}

	{
		re := MustCompile(".*")
		_ = re.FindSubmatchIndex([]byte("foobar")) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindStringSubmatchIndex`
	}

	{
		re := MustCompile(".*")
		_ = re.FindSubmatchIndex([]byte{'f','o','o','b','a','r'}) 
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindSubmatchIndex([]byte("foobar")) // want `avoid allocations with \(\*regexp\.Regexp\)\.FindStringSubmatchIndex`
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.FindSubmatchIndex([]byte{'f','o','o','b','a','r'}) 
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.Match([]byte("foobar")) // want `avoid allocations with \(\*regexp\.Regexp\)\.MatchString`
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.Match([]byte{'f','o','o','b','a','r'}) 
	}

	{
		re := MustCompile(".*")
		_ = re.Match([]byte("foobar")) // want `avoid allocations with \(\*regexp\.Regexp\)\.MatchString`
	}

	{
		re := MustCompile(".*")
		_ = re.Match([]byte{'f','o','o','b','a','r'}) 
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.Match([]byte("foobar")) // want `avoid allocations with \(\*regexp\.Regexp\)\.MatchString`
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.Match([]byte{'f','o','o','b','a','r'}) 
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.MatchString(string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with \(\*regexp\.Regexp\)\.Match`
	}

	{
		re := regexp.MustCompile(".*")
		_ = re.MatchString("foobar") 
	}

	{
		re := MustCompile(".*")
		_ = re.MatchString(string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with \(\*regexp\.Regexp\)\.Match`
	}

	{
		re := MustCompile(".*")
		_ = re.MatchString("foobar") 
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.MatchString(string([]byte{'f','o','o','b','a','r'})) // want `avoid allocations with \(\*regexp\.Regexp\)\.Match`
	}

	{
		re := pkg.MustCompile(".*")
		_ = re.MatchString("foobar") 
	}

}
